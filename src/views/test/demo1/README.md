# Demo 1：主线程阻塞 vs Time Slice vs Web Worker

这个 Demo 用同一类“CPU 密集计算”任务（约 5 秒）对比三种执行方式：

- **阻塞主线程**：同步执行，UI 会卡死。
- **Time Slice（时间切片）**：任务拆分成小片段，每片执行后让出主线程，UI 可响应。
- **Web Worker**：把任务放到独立线程，主线程基本不受影响。

---

## Q&A

### 1) 什么时候需要使用 Web Worker？

当你满足以下一个或多个条件时，建议优先考虑 Web Worker：

1. **持续 CPU 密集计算**（图像处理、音视频转码、复杂解析、加解密、压缩等）。
2. 主线程已有较多渲染/交互压力，卡顿可感知。
3. 任务耗时较长（通常几十毫秒以上就可能影响交互，几百毫秒以上用户会明显感知）。
4. 可以接受“线程通信成本”（序列化/拷贝或 Transferable 管理）。

➡️：**只要主线程会有算力压力，且任务适合异步通信，就该考虑 Worker。**

### 2) 一定要用 Web Worker 吗？什么时候用 Time Slice？

不一定。可以按这几个准则判断：

- **先看任务重不重**：
  - 轻量任务（偶发、总时长短）→ Time Slice 通常够用。
  - 重量任务（持续占用 CPU）→ 更适合 Worker。
- **再看开发复杂度**：
  - Time Slice 改造成本低，不需要额外线程通信。
  - Worker 结构更清晰，但要设计消息协议、错误处理、生命周期。
- **再看数据体积**：
  - 大对象频繁通信时，Worker 可能有传输开销。
  - 可以用 `Transferable` 降低拷贝成本（如 `ArrayBuffer`）。

实战建议：

1. 先用 Time Slice 快速缓解卡顿；
2. 若仍有明显掉帧/输入延迟，再升级为 Worker；
3. 复杂场景采用“主线程调度 + Worker 计算”组合。

### 3) Time Slice 用法与注意点

#### Time Slice 用法核心

- 把大任务拆成多个小片段执行；
- 每片执行后通过 `setTimeout(0)`（或 `requestIdleCallback` / 调度器 scheduler 方案）主动让出主线程；
- 周期性更新进度，让用户可感知任务在推进。

#### Time Slice 注意点

1. **分片预算要小**：单片过长（如 > 16ms）仍会掉帧。
2. **支持取消**：组件卸载或路由切换时应可中断（本 Demo 用 `cancelSliceRef`）。
3. **避免频繁 setState**：进度刷新可节流，否则额外渲染反而拖慢。
4. **不是并行**：Time Slice 只是“更礼貌地占用主线程”，本质仍在主线程算。

### 4) Web Worker 用法与注意点

#### Worker 用法核心

1. 主线程创建 Worker。
2. 用 `postMessage` 发送任务参数。
3. Worker 执行计算并回传结果。
4. 主线程根据消息更新 UI。

#### Worker 注意点

1. **通信协议清晰化**：建议像本 Demo 一样定义类型（`MainToWorkerMsg` / `WorkerToMainMsg`）。
2. **处理就绪态和错误态**：避免用户在 Worker 未 ready 时触发任务。
3. **及时销毁**：组件卸载时 `terminate()`，防止泄漏。
4. **关注传输成本**：大数据优先考虑 `Transferable`。
5. **Worker 无法直接操作 DOM**：UI 更新必须回到主线程。

---

## 在本 Demo 中观察差异

进入页面后分别点击三张卡片中的“运行”按钮，并在输入框持续输入：

1. **阻塞主线程**：输入明显卡住，按钮 loading 也会有延迟反馈。
2. **Time Slice**：输入基本可用，进度条逐步推进。
3. **Web Worker**：输入最流畅，主线程体验接近无任务状态。

建议在浏览器性能面板中同时观察：

- Main Thread 长任务（Long Task）
- FPS 变化
- 输入延迟（Event Timing）

---

## 结论

- **阻塞主线程**：实现简单，但交互体验最差，仅适合非常短的同步任务。
- **Time Slice**：低成本改造、显著改善交互，适合中等计算任务。
- **Web Worker**：主线程解耦最彻底，适合重计算与长任务。

> 一句话： **“轻任务先切片，重任务上 Worker。”**
